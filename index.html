<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Optimized Interactive Visualization: COE Prices & Vehicle Population</title>
  <script src="https://d3js.org/d3.v6.min.js"></script>
  <style>
    body {
      font-family: Arial, sans-serif;
      margin: 20px;
      background: #f4f4f4;
    }
    .container {
      background: #fff;
      padding: 20px;
      margin-bottom: 20px;
      border-radius: 4px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }
    h2 { margin-top: 0; }
    .axis path,
    .axis line { fill: none; stroke: #000; }
    .grid line { stroke: #ccc; stroke-dasharray: 3 3; }
    .line { fill: none; stroke-width: 2px; }
    .tooltip {
      position: absolute;
      text-align: center;
      background: lightsteelblue;
      padding: 5px;
      border: 1px solid #000;
      pointer-events: none;
      opacity: 0;
    }
    .brush .selection {
      fill: #777;
      fill-opacity: 0.3;
      stroke: #fff;
    }
    .checkbox-container { margin-bottom: 10px; }
    /* 为每个部分加上明显边框 */
    #description, .checkbox-container, #chart-container {
      border: 1px solid #ddd;
      border-radius: 4px;
    }
  </style>
</head>
<body>
  <!-- Description Section -->
  <div id="description" class="container">
    <h2>Hypothesis and Data Description</h2>
    <p>
      I hypothesize that there is a positive correlation between COE bidding prices and the overall vehicle population in Singapore. As the vehicle population increases, the demand for vehicle ownership intensifies, which may drive up COE bidding prices. Conversely, periods with a declining vehicle population might correspond with lower COE prices.
    </p>
    <p>
      The analysis uses two datasets: <strong>COE Bidding Results / Prices</strong> (from January 2010 to March 2025) and <strong>Annual Motor Vehicle Population by Vehicle Type</strong> (from January 2005 to December 2020). The main chart displays COE prices (left y-axis) and aggregated total vehicle count (right y-axis). Interactive filtering via checkboxes lets users toggle the series.
    </p>
  </div>
  
  <!-- Filtering Section -->
  <div class="container checkbox-container">
    <label><input type="checkbox" id="toggleCoe" checked> Show COE Bidding Prices</label>
    <label style="margin-left: 20px;"><input type="checkbox" id="toggleVehicle" checked> Show Total Vehicle Count</label>
  </div>
  
  <!-- Chart Section -->
  <div id="chart-container" class="container">
    <svg id="chart" width="900" height="500"></svg>
    <div class="tooltip" id="tooltip"></div>
  </div>
  
  <script>
    // Overall SVG dimensions
    const svgWidth = 900, svgHeight = 500;
    // Margins for focus (main chart) and context (overview chart)
    const margin = {top: 20, right: 60, bottom: 110, left: 60};
    const margin2 = {top: svgHeight - 90, right: 60, bottom: 30, left: 60};
    
    const focusWidth = svgWidth - margin.left - margin.right;
    const focusHeight = svgHeight - margin.top - margin.bottom - 60;  // reserve space for context
    const contextHeight = svgHeight - margin2.top - margin2.bottom;
    
    // Create SVG element
    const svg = d3.select("#chart")
                  .attr("width", svgWidth)
                  .attr("height", svgHeight);
    
    // Create focus group (main chart)
    const focus = svg.append("g")
                     .attr("class", "focus")
                     .attr("transform", `translate(${margin.left},${margin.top})`);
    
    // Create context group (overview chart)
    const context = svg.append("g")
                       .attr("class", "context")
                       .attr("transform", `translate(${margin2.left},${margin2.top})`);
    
    // Date parsing functions – adjust format if needed
    const parseDate = d3.timeParse("%Y-%m-%d");
    const parseYear = d3.timeParse("%Y");
    
    // 清理每一行数据，去除键和值多余的空白
    function cleanRow(row) {
      const newRow = {};
      Object.keys(row).forEach(key => {
        const trimmedKey = key.trim();
        newRow[trimmedKey] = typeof row[key] === "string" ? row[key].trim() : row[key];
      });
      return newRow;
    }
    
    // 加载 CSV 文件并预处理
    Promise.all([
      // COE 数据（假设字段为 "Bidding_Date" 和 "Price"，也支持备用 "Date" 和 "price"）
      d3.csv("https://raw.githubusercontent.com/carionb/0322/main/COEBiddingResultsPrices.csv", cleanRow),
      // 车辆数据（假设字段为 "year", "category", "type", "number", "total"）
      d3.csv("https://raw.githubusercontent.com/carionb/0322/main/AnnualMotorVehiclePopulationbyVehicleType.csv", cleanRow)
    ]).then(([coeData, vehicleData]) => {
      console.log("First row of COE data:", coeData[0]);
      console.log("First row of vehicle data:", vehicleData[0]);
      
      // 处理 COE 数据
      coeData.forEach(d => {
        // 使用 "Bidding_Date" 或 "Date"
        const dateStr = d.Bidding_Date || d.Date;
        if(dateStr) {
          d.date = parseDate(dateStr);
          if (!d.date) {
            console.error("Date parsing failed for:", dateStr);
          }
        } else {
          console.error("No valid date field found in row:", d);
        }
        d.price = +(d.Price || d.price);
      });
      
      // 处理车辆数据
      // 首先将每行的 "year" 和 "number" 转换为合适的格式
      vehicleData.forEach(d => {
        // 此处字段名为小写 "year"、"number"
        d.year = d.year ? d.year.trim() : "";
        d.number = +d.number; // 转换为数字
      });
      
      // 按年聚合车辆数量（求和）
      const aggregatedVehicleData = Array.from(
        d3.rollup(vehicleData, v => d3.sum(v, d => d.number), d => d.year),
        ([year, total]) => ({ year: parseYear(year), total })
      );
      
      // 调试输出聚合后的数据
      console.log("Aggregated vehicle data:", aggregatedVehicleData);
      
      // 确定 x 轴范围：取 COE 和车辆数据的最小/最大日期
      const xExtentCoe = d3.extent(coeData, d => d.date);
      const xExtentVehicle = d3.extent(aggregatedVehicleData, d => d.year);
      const overallXDomain = [d3.min([xExtentCoe[0], xExtentVehicle[0]]),
                              d3.max([xExtentCoe[1], xExtentVehicle[1]])];
      
      // 定义 focus 图的比例尺
      const x = d3.scaleTime().domain(overallXDomain).range([0, focusWidth]);
      const y0 = d3.scaleLinear().domain([0, d3.max(coeData, d => d.price)]).nice().range([focusHeight, 0]);
      const y1 = d3.scaleLinear().domain([0, d3.max(aggregatedVehicleData, d => d.total)]).nice().range([focusHeight, 0]);
      
      // 定义 context 图的比例尺（仅使用 COE 数据）
      const x2 = d3.scaleTime().domain(overallXDomain).range([0, focusWidth]);
      const y2 = d3.scaleLinear().domain([0, d3.max(coeData, d => d.price)]).nice().range([contextHeight, 0]);
      
      // 定义 focus 图的坐标轴
      const xAxis = d3.axisBottom(x);
      const yAxisLeft = d3.axisLeft(y0);
      const yAxisRight = d3.axisRight(y1);
      
      // 绘制 focus 坐标轴
      focus.append("g")
           .attr("class", "x axis")
           .attr("transform", `translate(0, ${focusHeight})`)
           .call(xAxis);
      
      focus.append("g")
           .attr("class", "y axis left")
           .call(yAxisLeft)
           .append("text")
           .attr("fill", "steelblue")
           .attr("transform", "rotate(-90)")
           .attr("y", -50)
           .attr("dy", "0.71em")
           .attr("text-anchor", "end")
           .text("COE Price");
      
      focus.append("g")
           .attr("class", "y axis right")
           .attr("transform", `translate(${focusWidth}, 0)`)
           .call(yAxisRight)
           .append("text")
           .attr("fill", "orange")
           .attr("transform", "rotate(-90)")
           .attr("y", 40)
           .attr("dy", "0.71em")
           .attr("text-anchor", "end")
           .text("Total Vehicle Count");
      
      // 添加 focus 图背景网格线
      function make_x_gridlines() { return d3.axisBottom(x).ticks(5); }
      function make_y_gridlines() { return d3.axisLeft(y0).ticks(5); }
      
      focus.append("g")
           .attr("class", "grid")
           .attr("transform", `translate(0, ${focusHeight})`)
           .call(make_x_gridlines().tickSize(-focusHeight).tickFormat(""));
      
      focus.append("g")
           .attr("class", "grid")
           .call(make_y_gridlines().tickSize(-focusWidth).tickFormat(""));
      
      // 定义 focus 图折线生成器
      const lineCoe = d3.line()
                        .x(d => x(d.date))
                        .y(d => y0(d.price));
      
      const lineVehicle = d3.line()
                            .x(d => x(d.year))
                            .y(d => y1(d.total));
      
      // 绘制 COE 价格折线
      const coePath = focus.append("path")
                           .datum(coeData)
                           .attr("class", "line coe-line")
                           .attr("stroke", "steelblue")
                           .attr("d", lineCoe);
      
      // 绘制车辆总量折线（使用聚合后的数据）
      const vehiclePath = focus.append("path")
                               .datum(aggregatedVehicleData)
                               .attr("class", "line vehicle-line")
                               .attr("stroke", "orange")
                               .attr("d", lineVehicle);
      
      // 添加 tooltip 圆点（COE 数据）
      const tooltip = d3.select("#tooltip");
      
      focus.selectAll(".dot-coe")
           .data(coeData)
           .enter()
           .append("circle")
           .attr("class", "dot-coe")
           .attr("cx", d => x(d.date))
           .attr("cy", d => y0(d.price))
           .attr("r", 3)
           .attr("fill", "steelblue")
           .on("mouseover", (event, d) => {
             tooltip.transition().duration(200).style("opacity", 0.9);
             tooltip.html(`Date: ${d3.timeFormat("%Y-%m-%d")(d.date)}<br/>Price: ${d.price}`)
                    .style("left", (event.pageX + 10) + "px")
                    .style("top", (event.pageY - 28) + "px");
           })
           .on("mouseout", () => {
             tooltip.transition().duration(500).style("opacity", 0);
           });
      
      // 添加 tooltip 圆点（车辆总量数据）
      focus.selectAll(".dot-vehicle")
           .data(aggregatedVehicleData)
           .enter()
           .append("circle")
           .attr("class", "dot-vehicle")
           .attr("cx", d => x(d.year))
           .attr("cy", d => y1(d.total))
           .attr("r", 3)
           .attr("fill", "orange")
           .on("mouseover", (event, d) => {
             tooltip.transition().duration(200).style("opacity", 0.9);
             tooltip.html(`Year: ${d3.timeFormat("%Y")(d.year)}<br/>Total: ${d.total}`)
                    .style("left", (event.pageX + 10) + "px")
                    .style("top", (event.pageY - 28) + "px");
           })
           .on("mouseout", () => {
             tooltip.transition().duration(500).style("opacity", 0);
           });
      
      // 绘制 context 图（概览），使用 COE 数据
      const contextLine = d3.line()
                            .x(d => x2(d.date))
                            .y(d => y2(d.price));
      
      context.append("path")
             .datum(coeData)
             .attr("class", "line context-line")
             .attr("stroke", "steelblue")
             .attr("d", contextLine);
      
      context.append("g")
             .attr("class", "x axis")
             .attr("transform", `translate(0, ${contextHeight})`)
             .call(d3.axisBottom(x2));
      
      // 添加 context 图刷选功能
      const brush = d3.brushX()
                      .extent([[0, 0], [focusWidth, contextHeight]])
                      .on("brush end", brushed);
      
      context.append("g")
             .attr("class", "brush")
             .call(brush)
             .call(brush.move, x.range());
      
      function brushed({selection}) {
        if (selection) {
          const [x0, x1] = selection;
          const newDomain = [x2.invert(x0), x2.invert(x1)];
          x.domain(newDomain);
          // 平滑更新 focus 图所有元素
          focus.select(".x.axis").transition().duration(750).call(xAxis);
          focus.selectAll(".coe-line").transition().duration(750).attr("d", lineCoe);
          focus.selectAll(".vehicle-line").transition().duration(750).attr("d", lineVehicle);
          focus.selectAll(".dot-coe").transition().duration(750).attr("cx", d => x(d.date));
          focus.selectAll(".dot-vehicle").transition().duration(750).attr("cx", d => x(d.year));
          // 更新网格线
          focus.selectAll(".grid").remove();
          focus.append("g")
                .attr("class", "grid")
                .attr("transform", `translate(0, ${focusHeight})`)
                .call(make_x_gridlines().tickSize(-focusHeight).tickFormat(""));
          focus.append("g")
                .attr("class", "grid")
                .call(make_y_gridlines().tickSize(-focusWidth).tickFormat(""));
        }
      }
      
      // 交互过滤：复选框控制各系列显示
      d3.select("#toggleCoe").on("change", function() {
        const display = this.checked ? null : "none";
        focus.selectAll(".coe-line").style("display", display);
        focus.selectAll(".dot-coe").style("display", display);
        context.selectAll(".context-line").style("display", display);
      });
      
      d3.select("#toggleVehicle").on("change", function() {
        const display = this.checked ? null : "none";
        focus.selectAll(".vehicle-line").style("display", display);
        focus.selectAll(".dot-vehicle").style("display", display);
      });
      
    }).catch(error => {
      console.error("Error loading CSV data:", error);
    });
  </script>
</body>
</html>
