<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Optimized Interactive Visualization: COE Prices & Vehicle Population</title>
  <script src="https://d3js.org/d3.v6.min.js"></script>
  <style>
    body {
      font-family: Arial, sans-serif;
      margin: 20px;
      background: #f4f4f4;
    }
    .container {
      background: #fff;
      padding: 20px;
      margin-bottom: 20px;
      border-radius: 4px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }
    h2 { margin-top: 0; }
    .axis path, .axis line { fill: none; stroke: #000; }
    .grid line { stroke: #ccc; stroke-dasharray: 3 3; }
    .line { fill: none; stroke-width: 2px; }
    .tooltip {
      position: absolute; text-align: center;
      background: lightsteelblue; padding: 5px;
      border: 1px solid #000; pointer-events: none; opacity: 0;
    }
    .brush .selection {
      fill: #777; fill-opacity: 0.3; stroke: #fff;
    }
    .checkbox-container { margin-bottom: 10px; }
    /* 部分容器外边框 */
    #description, .checkbox-container, #chart-container {
      border: 1px solid #ddd;
      border-radius: 4px;
    }
  </style>
</head>
<body>
  <!-- Description Section -->
  <div id="description" class="container">
    <h2>Hypothesis and Data Description</h2>
    <p>
      I hypothesize that there is a positive correlation between COE bidding prices and the overall vehicle population in Singapore. As the vehicle population increases, the demand for vehicle ownership intensifies, which may drive up COE bidding prices. Conversely, periods with a declining vehicle population might correspond with lower COE prices.
    </p>
    <p>
      The analysis uses two datasets: <strong>COE Bidding Results / Prices</strong> (from January 2010 to March 2025) and <strong>Annual Motor Vehicle Population by Vehicle Type</strong> (from January 2005 to December 2020). The main chart displays COE prices (left y-axis) and total vehicle count (right y-axis). Interactive filtering via checkboxes lets users toggle the series.
    </p>
  </div>
  
  <!-- Filtering Section -->
  <div class="container checkbox-container">
    <label><input type="checkbox" id="toggleCoe" checked> Show COE Bidding Prices</label>
    <label style="margin-left: 20px;"><input type="checkbox" id="toggleVehicle" checked> Show Total Vehicle Count</label>
  </div>
  
  <!-- Chart Section -->
  <div id="chart-container" class="container">
    <svg id="chart" width="900" height="500"></svg>
    <div class="tooltip" id="tooltip"></div>
  </div>
  
  <script>
    // Overall SVG dimensions
    const svgWidth = 900, svgHeight = 500;
    
    // Margins for focus (main chart) and context (overview chart)
    const margin = {top: 20, right: 60, bottom: 110, left: 60};
    const margin2 = {top: svgHeight - 90, right: 60, bottom: 30, left: 60};
    
    const focusWidth = svgWidth - margin.left - margin.right;
    const focusHeight = svgHeight - margin.top - margin.bottom - 60;  // reserve space for context
    const contextHeight = svgHeight - margin2.top - margin2.bottom;
    
    // Create SVG element
    const svg = d3.select("#chart")
                  .attr("width", svgWidth)
                  .attr("height", svgHeight);
    
    // Create focus group (main chart)
    const focus = svg.append("g")
                     .attr("class", "focus")
                     .attr("transform", `translate(${margin.left},${margin.top})`);
    
    // Create context group (overview chart)
    const context = svg.append("g")
                       .attr("class", "context")
                       .attr("transform", `translate(${margin2.left},${margin2.top})`);
    
    // Date parsing functions – adjust format if needed
    const parseDate = d3.timeParse("%Y-%m-%d");
    const parseYear = d3.timeParse("%Y");
    
    // 加入一个函数用于清理每一行数据（trim所有键和值）
    function cleanRow(row) {
      const newRow = {};
      Object.keys(row).forEach(key => {
        const trimmedKey = key.trim();
        newRow[trimmedKey] = typeof row[key] === "string" ? row[key].trim() : row[key];
      });
      return newRow;
    }
    
    // Load CSV files from GitHub
    Promise.all([
      d3.csv("https://raw.githubusercontent.com/carionb/0322/main/COEBiddingResultsPrices.csv", cleanRow),
      d3.csv("https://raw.githubusercontent.com/carionb/0322/main/AnnualMotorVehiclePopulationbyVehicleType.csv", cleanRow)
    ]).then(([coeData, vehicleData]) => {
      // 输出第一行数据查看实际字段
      console.log("First row of COE data:", coeData[0]);
      console.log("First row of vehicle data:", vehicleData[0]);
      
      // Process COE data
      coeData.forEach(d => {
        // 使用 "Bidding_Date" 或 "Date"
        const dateStr = d.Bidding_Date || d.Date;
        if(dateStr) {
          d.date = parseDate(dateStr);
          if (!d.date) {
            console.error("Date parsing failed for:", dateStr);
          }
        } else {
          console.error("No valid date field found in row:", d);
        }
        d.price = +(d.Price || d.price);
      });
      
      // Process vehicle population data
      vehicleData.forEach(d => {
        if(d.Year) {
          d.Year = parseYear(d.Year);
        } else {
          console.error("No Year field in row:", d);
        }
        d.total = +(d.Car) + +(d.LGV) + +(d.HGV) + +(d.VHGV);
      });
      
      // Determine overall x-axis domain from both datasets
      const xExtentCoe = d3.extent(coeData, d => d.date);
      const xExtentVehicle = d3.extent(vehicleData, d => d.Year);
      const overallXDomain = [d3.min([xExtentCoe[0], xExtentVehicle[0]]),
                              d3.max([xExtentCoe[1], xExtentVehicle[1]])];
      
      // Define scales for focus chart
      const x = d3.scaleTime().domain(overallXDomain).range([0, focusWidth]);
      const y0 = d3.scaleLinear().domain([0, d3.max(coeData, d => d.price)]).nice().range([focusHeight, 0]);
      const y1 = d3.scaleLinear().domain([0, d3.max(vehicleData, d => d.total)]).nice().range([focusHeight, 0]);
      
      // Define scales for context chart (using COE data only)
      const x2 = d3.scaleTime().domain(overallXDomain).range([0, focusWidth]);
      const y2 = d3.scaleLinear().domain([0, d3.max(coeData, d => d.price)]).nice().range([contextHeight, 0]);
      
      // Define axes for focus chart
      const xAxis = d3.axisBottom(x);
      const yAxisLeft = d3.axisLeft(y0);
      const yAxisRight = d3.axisRight(y1);
      
      // Draw focus axes
      focus.append("g")
           .attr("class", "x axis")
           .attr("transform", `translate(0, ${focusHeight})`)
           .call(xAxis);
      
      focus.append("g")
           .attr("class", "y axis left")
           .call(yAxisLeft)
           .append("text")
           .attr("fill", "steelblue")
           .attr("transform", "rotate(-90)")
           .attr("y", -50)
           .attr("dy", "0.71em")
           .attr("text-anchor", "end")
           .text("COE Price");
      
      focus.append("g")
           .attr("class", "y axis right")
           .attr("transform", `translate(${focusWidth}, 0)`)
           .call(yAxisRight)
           .append("text")
           .attr("fill", "orange")
           .attr("transform", "rotate(-90)")
           .attr("y", 40)
           .attr("dy", "0.71em")
           .attr("text-anchor", "end")
           .text("Total Vehicle Count");
      
      // Add gridlines to focus chart
      function make_x_gridlines() { return d3.axisBottom(x).ticks(5); }
      function make_y_gridlines() { return d3.axisLeft(y0).ticks(5); }
      
      focus.append("g")
           .attr("class", "grid")
           .attr("transform", `translate(0, ${focusHeight})`)
           .call(make_x_gridlines().tickSize(-focusHeight).tickFormat(""));
      
      focus.append("g")
           .attr("class", "grid")
           .call(make_y_gridlines().tickSize(-focusWidth).tickFormat(""));
      
      // Define line generators for focus chart
      const lineCoe = d3.line()
                        .x(d => x(d.date))
                        .y(d => y0(d.price));
      
      const lineVehicle = d3.line()
                            .x(d => x(d.Year))
                            .y(d => y1(d.total));
      
      // Draw lines in focus chart
      const coePath = focus.append("path")
                           .datum(coeData)
                           .attr("class", "line coe-line")
                           .attr("stroke", "steelblue")
                           .attr("d", lineCoe);
      
      const vehiclePath = focus.append("path")
                               .datum(vehicleData)
                               .attr("class", "line vehicle-line")
                               .attr("stroke", "orange")
                               .attr("d", lineVehicle);
      
      // Add tooltip circles for COE and vehicle data
      const tooltip = d3.select("#tooltip");
      
      focus.selectAll(".dot-coe")
           .data(coeData)
           .enter()
           .append("circle")
           .attr("class", "dot-coe")
           .attr("cx", d => x(d.date))
           .attr("cy", d => y0(d.price))
           .attr("r", 3)
           .attr("fill", "steelblue")
           .on("mouseover", (event, d) => {
             tooltip.transition().duration(200).style("opacity", 0.9);
             tooltip.html(`Date: ${d3.timeFormat("%Y-%m-%d")(d.date)}<br/>Price: ${d.price}`)
                    .style("left", (event.pageX + 10) + "px")
                    .style("top", (event.pageY - 28) + "px");
           })
           .on("mouseout", () => {
             tooltip.transition().duration(500).style("opacity", 0);
           });
      
      focus.selectAll(".dot-vehicle")
           .data(vehicleData)
           .enter()
           .append("circle")
           .attr("class", "dot-vehicle")
           .attr("cx", d => x(d.Year))
           .attr("cy", d => y1(d.total))
           .attr("r", 3)
           .attr("fill", "orange")
           .on("mouseover", (event, d) => {
             tooltip.transition().duration(200).style("opacity", 0.9);
             tooltip.html(`Year: ${d3.timeFormat("%Y")(d.Year)}<br/>Total: ${d.total}`)
                    .style("left", (event.pageX + 10) + "px")
                    .style("top", (event.pageY - 28) + "px");
           })
           .on("mouseout", () => {
             tooltip.transition().duration(500).style("opacity", 0);
           });
      
      // Draw context chart (overview) using COE data
      const contextLine = d3.line()
                            .x(d => x2(d.date))
                            .y(d => y2(d.price));
      
      context.append("path")
             .datum(coeData)
             .attr("class", "line context-line")
             .attr("stroke", "steelblue")
             .attr("d", contextLine);
      
      context.append("g")
             .attr("class", "x axis")
             .attr("transform", `translate(0, ${contextHeight})`)
             .call(d3.axisBottom(x2));
      
      // Add brushing to context chart
      const brush = d3.brushX()
                      .extent([[0, 0], [focusWidth, contextHeight]])
                      .on("brush end", brushed);
      
      context.append("g")
             .attr("class", "brush")
             .call(brush)
             .call(brush.move, x.range());
      
      function brushed({selection}) {
        if (selection) {
          const [x0, x1] = selection;
          const newDomain = [x2.invert(x0), x2.invert(x1)];
          x.domain(newDomain);
          // Transition focus elements smoothly
          focus.select(".x.axis").transition().duration(750).call(xAxis);
          focus.selectAll(".coe-line").transition().duration(750).attr("d", lineCoe);
          focus.selectAll(".vehicle-line").transition().duration(750).attr("d", lineVehicle);
          focus.selectAll(".dot-coe").transition().duration(750).attr("cx", d => x(d.date));
          focus.selectAll(".dot-vehicle").transition().duration(750).attr("cx", d => x(d.Year));
          // Update gridlines: remove and re-add for updated x-scale
          focus.selectAll(".grid").remove();
          focus.append("g")
                .attr("class", "grid")
                .attr("transform", `translate(0, ${focusHeight})`)
                .call(make_x_gridlines().tickSize(-focusHeight).tickFormat(""));
          focus.append("g")
                .attr("class", "grid")
                .call(make_y_gridlines().tickSize(-focusWidth).tickFormat(""));
        }
      }
      
      // Interactive filtering using checkboxes
      d3.select("#toggleCoe").on("change", function() {
        const display = this.checked ? null : "none";
        focus.selectAll(".coe-line").style("display", display);
        focus.selectAll(".dot-coe").style("display", display);
        context.selectAll(".context-line").style("display", display);
      });
      
      d3.select("#toggleVehicle").on("change", function() {
        const display = this.checked ? null : "none";
        focus.selectAll(".vehicle-line").style("display", display);
        focus.selectAll(".dot-vehicle").style("display", display);
      });
      
    }).catch(error => {
      console.error("Error loading CSV data:", error);
    });
  </script>
</body>
</html>
